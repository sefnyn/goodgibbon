<MACRO>
<NAME>GSGF_TYPE_RESULT</NAME>
#define GSGF_TYPE_RESULT \
        (gsgf_result_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_RESULT</NAME>
#define GSGF_RESULT(obj) \
        (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_RESULT, \
                GSGFResult))
</MACRO>
<MACRO>
<NAME>GSGF_RESULT_CLASS</NAME>
#define GSGF_RESULT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), \
        GSGF_TYPE_RESULT, GSGFResultClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_RESULT</NAME>
#define GSGF_IS_RESULT(obj) \
        (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
                GSGF_TYPE_RESULT))
</MACRO>
<MACRO>
<NAME>GSGF_IS_RESULT_CLASS</NAME>
#define GSGF_IS_RESULT_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_TYPE ((klass), \
                GSGF_TYPE_RESULT))
</MACRO>
<MACRO>
<NAME>GSGF_RESULT_GET_CLASS</NAME>
#define GSGF_RESULT_GET_CLASS(obj) \
        (G_TYPE_INSTANCE_GET_CLASS ((obj), \
                GSGF_TYPE_RESULT, GSGFResultClass))
</MACRO>
<STRUCT>
<NAME>GSGFResult</NAME>
struct _GSGFResult
{
        GSGFSimpleText parent_instance;

        /*< private >*/
        struct _GSGFResultPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GSGFResultClass</NAME>
struct _GSGFResultClass
{
        /* <private >*/
        GSGFSimpleTextClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_result_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GSGFResultWinner</NAME>
typedef enum {
        GSGF_RESULT_BLACK = 0,
        GSGF_RESULT_WHITE = 1,
        GSGF_RESULT_DRAW = 2,
        GSGF_RESULT_VOID = 3,
        GSGF_RESULT_UNKNOWN = 32767
} GSGFResultWinner;
</ENUM>
<ENUM>
<NAME>GSGFResultCause</NAME>
typedef enum {
        GSGF_RESULT_NORMAL = 0,
        GSGF_RESULT_RESIGNATION = 1,
        GSGF_RESULT_TIME = 2,
        GSGF_RESULT_FORFEIT = 3,
        GSGF_RESULT_OTHER = 32767
} GSGFResultCause;
</ENUM>
<FUNCTION>
<NAME>gsgf_result_new</NAME>
<RETURNS>GSGFResult  *</RETURNS>
GSGFResultWinner winner, gdouble score, GSGFResultCause cause
</FUNCTION>
<FUNCTION>
<NAME>gsgf_result_new_from_raw</NAME>
<RETURNS>GSGFCookedValue  *</RETURNS>
const GSGFRaw* raw, const GSGFFlavor *flavor, const struct _GSGFProperty *property, GError **error
</FUNCTION>
<FUNCTION>
<NAME>gsgf_result_get_winner</NAME>
<RETURNS>GSGFResultWinner  </RETURNS>
const GSGFResult *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_result_get_cause</NAME>
<RETURNS>GSGFResultCause  </RETURNS>
const GSGFResult *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_result_get_score</NAME>
<RETURNS>gdouble  </RETURNS>
const GSGFResult *self
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_DATE</NAME>
#define GSGF_TYPE_DATE \
        (gsgf_date_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_DATE</NAME>
#define GSGF_DATE(obj) \
        (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_DATE, \
                GSGFDate))
</MACRO>
<MACRO>
<NAME>GSGF_DATE_CLASS</NAME>
#define GSGF_DATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), \
        GSGF_TYPE_DATE, GSGFDateClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_DATE</NAME>
#define GSGF_IS_DATE(obj) \
        (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
                GSGF_TYPE_DATE))
</MACRO>
<MACRO>
<NAME>GSGF_IS_DATE_CLASS</NAME>
#define GSGF_IS_DATE_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_TYPE ((klass), \
                GSGF_TYPE_DATE))
</MACRO>
<MACRO>
<NAME>GSGF_DATE_GET_CLASS</NAME>
#define GSGF_DATE_GET_CLASS(obj) \
        (G_TYPE_INSTANCE_GET_CLASS ((obj), \
                GSGF_TYPE_DATE, GSGFDateClass))
</MACRO>
<STRUCT>
<NAME>GSGFDate</NAME>
struct _GSGFDate
{
        GSGFSimpleText parent_instance;

        /*< private >*/
        struct _GSGFDatePrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GSGFDateClass</NAME>
struct _GSGFDateClass
{
        /* <private >*/
        GSGFSimpleTextClass parent_class;
};
</STRUCT>
<STRUCT>
<NAME>GSGFDateDMY</NAME>
struct _GSGFDateDMY {
        guint day: 6;
        guint month: 4;
        guint year: 16;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_date_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gsgf_date_new</NAME>
<RETURNS>GSGFDate  *</RETURNS>
GSGFDateDMY *date, GError **error
</FUNCTION>
<FUNCTION>
<NAME>gsgf_date_new_from_raw</NAME>
<RETURNS>GSGFCookedValue  *</RETURNS>
const GSGFRaw *raw, const GSGFFlavor *flavor, const struct _GSGFProperty *property, GError **error
</FUNCTION>
<FUNCTION>
<NAME>gsgf_date_append</NAME>
<RETURNS>gboolean  </RETURNS>
GSGFDate *self, GSGFDateDMY *date, GError **error
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_GAME_TREE</NAME>
#define GSGF_TYPE_GAME_TREE             (gsgf_game_tree_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_GAME_TREE</NAME>
#define GSGF_GAME_TREE(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
		GSGF_TYPE_GAME_TREE, GSGFGameTree))
</MACRO>
<MACRO>
<NAME>GSGF_GAME_TREE_CLASS</NAME>
#define GSGF_GAME_TREE_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), \
		GSGF_TYPE_GAME_TREE, GSGFGameTreeClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_GAME_TREE</NAME>
#define GSGF_IS_GAME_TREE(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
		GSGF_TYPE_GAME_TREE))
</MACRO>
<MACRO>
<NAME>GSGF_IS_GAME_TREE_CLASS</NAME>
#define GSGF_IS_GAME_TREE_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
		GSGF_TYPE_GAME_TREE))
</MACRO>
<MACRO>
<NAME>GSGF_GAME_TREE_GET_CLASS</NAME>
#define GSGF_GAME_TREE_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), \
		GSGF_TYPE_GAME_TREE, GSGFGameTreeClass))
</MACRO>
<STRUCT>
<NAME>GSGFGameTree</NAME>
struct _GSGFGameTree
{
        GObject parent_instance;

        /*< private >*/
        struct _GSGFGameTreePrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GSGFGameTreeClass</NAME>
struct _GSGFGameTreeClass
{
        /*< private >*/
        GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_game_tree_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gsgf_game_tree_add_child</NAME>
<RETURNS>GSGFGameTree  *</RETURNS>
GSGFGameTree *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_game_tree_get_parent</NAME>
<RETURNS>GSGFGameTree  *</RETURNS>
const GSGFGameTree *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_game_tree_add_node</NAME>
<RETURNS>struct _GSGFNode  *</RETURNS>
GSGFGameTree *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_game_tree_get_nodes</NAME>
<RETURNS>GList  *</RETURNS>
const GSGFGameTree *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_game_tree_get_last_node</NAME>
<RETURNS>GList  *</RETURNS>
const GSGFGameTree *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_game_tree_get_children</NAME>
<RETURNS>GList  *</RETURNS>
const GSGFGameTree *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_game_tree_get_flavor</NAME>
<RETURNS>const GSGFFlavor  *</RETURNS>
const GSGFGameTree *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_game_tree_set_application</NAME>
<RETURNS>gboolean  </RETURNS>
GSGFGameTree *self, const gchar *app, const gchar *version, GError **error
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_NODE</NAME>
#define GSGF_TYPE_NODE                  (gsgf_node_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_NODE</NAME>
#define GSGF_NODE(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
		GSGF_TYPE_NODE, GSGFNode))
</MACRO>
<MACRO>
<NAME>GSGF_NODE_CLASS</NAME>
#define GSGF_NODE_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), \
		GSGF_TYPE_NODE, GSGFNodeClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_NODE</NAME>
#define GSGF_IS_NODE(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
		GSGF_TYPE_NODE))
</MACRO>
<MACRO>
<NAME>GSGF_IS_NODE_CLASS</NAME>
#define GSGF_IS_NODE_CLASS(klass)       (G_TYPE_CHECK_CLASS_TYPE ((klass), \
		GSGF_TYPE_NODE))
</MACRO>
<MACRO>
<NAME>GSGF_NODE_GET_CLASS</NAME>
#define GSGF_NODE_GET_CLASS(obj)        (G_TYPE_INSTANCE_GET_CLASS ((obj), \
		GSGF_TYPE_NODE, GSGFNodeClass))
</MACRO>
<STRUCT>
<NAME>GSGFNode</NAME>
struct _GSGFNode
{
        GObject parent_instance;

        /*< private >*/
        struct _GSGFNodePrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GSGFNodeClass</NAME>
struct _GSGFNodeClass
{
        /*< private >*/
        GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_node_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gsgf_node_add_property</NAME>
<RETURNS>struct _GSGFProperty  *</RETURNS>
GSGFNode *self, const gchar *id, GError **error
</FUNCTION>
<FUNCTION>
<NAME>gsgf_node_get_property</NAME>
<RETURNS>struct _GSGFProperty  *</RETURNS>
const GSGFNode *self, const gchar *id
</FUNCTION>
<FUNCTION>
<NAME>gsgf_node_get_property_ids</NAME>
<RETURNS>GList  *</RETURNS>
const GSGFNode *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_node_remove_property</NAME>
<RETURNS>void  </RETURNS>
GSGFNode *self, const gchar *id
</FUNCTION>
<FUNCTION>
<NAME>gsgf_node_get_property_value</NAME>
<RETURNS>GSGFValue  *</RETURNS>
const GSGFNode *self, const gchar *id
</FUNCTION>
<FUNCTION>
<NAME>gsgf_node_get_previous_node</NAME>
<RETURNS>GSGFNode  *</RETURNS>
const GSGFNode *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_node_get_flavor</NAME>
<RETURNS>const GSGFFlavor  *</RETURNS>
const GSGFNode *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_node_get_game_tree</NAME>
<RETURNS>GSGFGameTree  *</RETURNS>
const GSGFNode *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_node_set_property</NAME>
<RETURNS>gboolean  </RETURNS>
GSGFNode *self, const gchar *id, GSGFValue *value, GError **error
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_COOKED_VALUE</NAME>
#define GSGF_TYPE_COOKED_VALUE             (gsgf_cooked_value_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_COOKED_VALUE</NAME>
#define GSGF_COOKED_VALUE(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
                GSGF_TYPE_COOKED_VALUE, GSGFCookedValue))
</MACRO>
<MACRO>
<NAME>GSGF_COOKED_VALUE_CLASS</NAME>
#define GSGF_COOKED_VALUE_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), \
                GSGF_TYPE_COOKED_VALUE, GSGFCookedValueClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_COOKED_VALUE</NAME>
#define GSGF_IS_COOKED_VALUE(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
                GSGF_TYPE_COOKED_VALUE))
</MACRO>
<MACRO>
<NAME>GSGF_IS_COOKED_VALUE_CLASS</NAME>
#define GSGF_IS_COOKED_VALUE_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
                GSGF_TYPE_COOKED_VALUE))
</MACRO>
<MACRO>
<NAME>GSGF_COOKED_VALUE_GET_CLASS</NAME>
#define GSGF_COOKED_VALUE_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), \
                GSGF_TYPE_COOKED_VALUE, GSGFCookedValueClass))
</MACRO>
<STRUCT>
<NAME>GSGFCookedValue</NAME>
struct _GSGFCookedValue
{
        GSGFValue parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GSGFCookedValueClass</NAME>
struct _GSGFCookedValueClass
{
        /*< private >*/
        GSGFValueClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_cooked_value_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gsgf_threads_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gsgf_util_read_simple_text</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *raw, const gchar **end, gchar delim
</FUNCTION>
<FUNCTION>
<NAME>gsgf_util_read_text</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *raw, const gchar **end, gchar delim
</FUNCTION>
<FUNCTION>
<NAME>gsgf_ascii_dtostring</NAME>
<RETURNS>gchar  *</RETURNS>
gdouble d, gint width, gint precision, gboolean zeropad, gboolean zerotrim
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_MOVE_BACKGAMMON</NAME>
#define GSGF_TYPE_MOVE_BACKGAMMON  			  \
	(gsgf_move_backgammon_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_MOVE_BACKGAMMON</NAME>
#define GSGF_MOVE_BACKGAMMON(obj)             \
	(G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_MOVE_BACKGAMMON, \
			GSGFMoveBackgammon))
</MACRO>
<MACRO>
<NAME>GSGF_MOVE_BACKGAMMON_CLASS</NAME>
#define GSGF_MOVE_BACKGAMMON_CLASS(klass)     \
	(G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_MOVE_BACKGAMMON, \
			GSGFMoveBackgammonClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_MOVE_BACKGAMMON</NAME>
#define GSGF_IS_MOVE_BACKGAMMON(obj)          \
	(G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_MOVE_BACKGAMMON))
</MACRO>
<MACRO>
<NAME>GSGF_IS_MOVE_BACKGAMMON_CLASS</NAME>
#define GSGF_IS_MOVE_BACKGAMMON_CLASS(klass)  \
	(G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_MOVE_BACKGAMMON))
</MACRO>
<MACRO>
<NAME>GSGF_MOVE_BACKGAMMON_GET_CLASS</NAME>
#define GSGF_MOVE_BACKGAMMON_GET_CLASS(obj)   \
	(G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_MOVE_BACKGAMMON, \
			GSGFMoveBackgammonClass))
</MACRO>
<STRUCT>
<NAME>GSGFMoveBackgammon</NAME>
struct _GSGFMoveBackgammon
{
        GSGFMove parent_instance;

        /*< private >*/
        struct _GSGFMoveBackgammonPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GSGFMoveBackgammonClass</NAME>
struct _GSGFMoveBackgammonClass
{
        /*< private >*/
        GSGFMoveClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_move_backgammon_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gsgf_move_backgammon_new</NAME>
<RETURNS>GSGFMoveBackgammon  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gsgf_move_backgammon_new_from_raw</NAME>
<RETURNS>GSGFMoveBackgammon  *</RETURNS>
const GSGFRaw *raw, GError **error
</FUNCTION>
<FUNCTION>
<NAME>gsgf_move_backgammon_new_from_string</NAME>
<RETURNS>GSGFMoveBackgammon  *</RETURNS>
const gchar *str, GError **error
</FUNCTION>
<FUNCTION>
<NAME>gsgf_move_backgammon_new_regular</NAME>
<RETURNS>GSGFMoveBackgammon  *</RETURNS>
guint die1, guint die2, GError **error, ...
</FUNCTION>
<FUNCTION>
<NAME>gsgf_move_backgammon_is_regular</NAME>
<RETURNS>gboolean  </RETURNS>
const GSGFMoveBackgammon *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_move_backgammon_is_double</NAME>
<RETURNS>gboolean  </RETURNS>
const GSGFMoveBackgammon *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_move_backgammon_is_take</NAME>
<RETURNS>gboolean  </RETURNS>
const GSGFMoveBackgammon *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_move_backgammon_is_drop</NAME>
<RETURNS>gboolean  </RETURNS>
const GSGFMoveBackgammon *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_move_backgammon_is_resign</NAME>
<RETURNS>guint  </RETURNS>
const GSGFMoveBackgammon *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_move_backgammon_is_accept</NAME>
<RETURNS>gboolean  </RETURNS>
const GSGFMoveBackgammon *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_move_backgammon_is_reject</NAME>
<RETURNS>gboolean  </RETURNS>
const GSGFMoveBackgammon *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_move_backgammon_get_num_moves</NAME>
<RETURNS>gsize  </RETURNS>
const GSGFMoveBackgammon *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_move_backgammon_get_die</NAME>
<RETURNS>guint  </RETURNS>
const GSGFMoveBackgammon *self, gsize i
</FUNCTION>
<FUNCTION>
<NAME>gsgf_move_backgammon_get_from</NAME>
<RETURNS>guint  </RETURNS>
const GSGFMoveBackgammon *self, gsize i
</FUNCTION>
<FUNCTION>
<NAME>gsgf_move_backgammon_get_to</NAME>
<RETURNS>guint  </RETURNS>
const GSGFMoveBackgammon *self, gsize i
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_COLLECTION</NAME>
#define GSGF_TYPE_COLLECTION             \
	(gsgf_collection_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_COLLECTION</NAME>
#define GSGF_COLLECTION(obj)             \
	(G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_COLLECTION, \
	                GSGFCollection))
</MACRO>
<MACRO>
<NAME>GSGF_COLLECTION_CLASS</NAME>
#define GSGF_COLLECTION_CLASS(klass)     \
	(G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_COLLECTION, \
			GSGFCollectionClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_COLLECTION</NAME>
#define GSGF_IS_COLLECTION(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
		GSGF_TYPE_COLLECTION))
</MACRO>
<MACRO>
<NAME>GSGF_IS_COLLECTION_CLASS</NAME>
#define GSGF_IS_COLLECTION_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
		GSGF_TYPE_COLLECTION))
</MACRO>
<MACRO>
<NAME>GSGF_COLLECTION_GET_CLASS</NAME>
#define GSGF_COLLECTION_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), \
		GSGF_TYPE_COLLECTION, GSGFCollectionClass))
</MACRO>
<STRUCT>
<NAME>GSGFCollection</NAME>
struct _GSGFCollection
{
        GObject parent_instance;

        /*< private >*/
        struct _GSGFCollectionPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GSGFCollectionClass</NAME>
struct _GSGFCollectionClass
{
        /*< private >*/
        GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_collection_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gsgf_collection_new</NAME>
<RETURNS>GSGFCollection  *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>gsgf_collection_parse_stream</NAME>
<RETURNS>GSGFCollection  *</RETURNS>
GInputStream *stream, GCancellable *cancellable, GError **error
</FUNCTION>
<FUNCTION>
<NAME>gsgf_collection_parse_file</NAME>
<RETURNS>GSGFCollection  *</RETURNS>
GFile *file, GCancellable *cancellable, GError **error
</FUNCTION>
<FUNCTION>
<NAME>gsgf_collection_add_game_tree</NAME>
<RETURNS>struct _GSGFGameTree  *</RETURNS>
GSGFCollection *self, const GSGFFlavor *flavor
</FUNCTION>
<FUNCTION>
<NAME>gsgf_collection_get_game_trees</NAME>
<RETURNS>GList  *</RETURNS>
const GSGFCollection *self
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_POINT_BACKGAMMON</NAME>
#define GSGF_TYPE_POINT_BACKGAMMON  (gsgf_point_backgammon_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_POINT_BACKGAMMON</NAME>
#define GSGF_POINT_BACKGAMMON(obj)             \
	(G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_POINT_BACKGAMMON, \
			GSGFPointBackgammon))
</MACRO>
<MACRO>
<NAME>GSGF_POINT_BACKGAMMON_CLASS</NAME>
#define GSGF_POINT_BACKGAMMON_CLASS(klass)     \
	(G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_POINT_BACKGAMMON, \
			GSGFPointBackgammonClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_POINT_BACKGAMMON</NAME>
#define GSGF_IS_POINT_BACKGAMMON(obj)          \
	(G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_POINT_BACKGAMMON))
</MACRO>
<MACRO>
<NAME>GSGF_IS_POINT_BACKGAMMON_CLASS</NAME>
#define GSGF_IS_POINT_BACKGAMMON_CLASS(klass)  \
	(G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_POINT_BACKGAMMON))
</MACRO>
<MACRO>
<NAME>GSGF_POINT_BACKGAMMON_GET_CLASS</NAME>
#define GSGF_POINT_BACKGAMMON_GET_CLASS(obj)   \
	(G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_POINT_BACKGAMMON, \
			GSGFPointBackgammonClass))
</MACRO>
<STRUCT>
<NAME>GSGFPointBackgammon</NAME>
struct _GSGFPointBackgammon
{
        GSGFPoint parent_instance;

        /*< private >*/
        struct _GSGFPointBackgammonPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GSGFPointBackgammonClass</NAME>
struct _GSGFPointBackgammonClass
{
        /*< private >*/
        GSGFPointClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_point_backgammon_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gsgf_point_backgammon_new</NAME>
<RETURNS>GSGFPointBackgammon  *</RETURNS>
gint point
</FUNCTION>
<FUNCTION>
<NAME>gsgf_point_backgammon_new_from_raw</NAME>
<RETURNS>GSGFPointBackgammon  *</RETURNS>
const GSGFRaw *raw, gsize i, GError **error
</FUNCTION>
<FUNCTION>
<NAME>gsgf_point_backgammon_append_to_list_of</NAME>
<RETURNS>gboolean  </RETURNS>
struct _GSGFListOf *list_of, const GSGFRaw *raw, gsize i, GError **error
</FUNCTION>
<FUNCTION>
<NAME>gsgf_point_backgammon_get_point</NAME>
<RETURNS>gint  </RETURNS>
const GSGFPointBackgammon *self
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_COLOR</NAME>
#define GSGF_TYPE_COLOR \
        (gsgf_color_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_COLOR</NAME>
#define GSGF_COLOR(obj) \
        (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_COLOR, \
                GSGFColor))
</MACRO>
<MACRO>
<NAME>GSGF_COLOR_CLASS</NAME>
#define GSGF_COLOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), \
        GSGF_TYPE_COLOR, GSGFColorClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_COLOR</NAME>
#define GSGF_IS_COLOR(obj) \
        (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
                GSGF_TYPE_COLOR))
</MACRO>
<MACRO>
<NAME>GSGF_IS_COLOR_CLASS</NAME>
#define GSGF_IS_COLOR_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_TYPE ((klass), \
                GSGF_TYPE_COLOR))
</MACRO>
<MACRO>
<NAME>GSGF_COLOR_GET_CLASS</NAME>
#define GSGF_COLOR_GET_CLASS(obj) \
        (G_TYPE_INSTANCE_GET_CLASS (obj), \
                GSGF_TYPE_COLOR, GSGFColorClass))
</MACRO>
<STRUCT>
<NAME>GSGFColor</NAME>
struct _GSGFColor
{
        GSGFCookedValue parent_instance;

        /*< private >*/
        struct _GSGFColorPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GSGFColorClass</NAME>
struct _GSGFColorClass
{
        /* <private >*/
        GSGFCookedValueClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_color_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GSGFColorEnum</NAME>
typedef enum {
        GSGF_COLOR_WHITE = 1,
        GSGF_COLOR_BLACK = 0
} GSGFColorEnum;
</ENUM>
<FUNCTION>
<NAME>gsgf_color_new</NAME>
<RETURNS>GSGFColor  *</RETURNS>
GSGFColorEnum color
</FUNCTION>
<FUNCTION>
<NAME>gsgf_color_get_color</NAME>
<RETURNS>GSGFColorEnum  </RETURNS>
const GSGFColor *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_color_new_from_raw</NAME>
<RETURNS>GSGFCookedValue  *</RETURNS>
const GSGFRaw* raw, const GSGFFlavor *flavor, const struct _GSGFProperty *property, GError **error
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_EMPTY</NAME>
#define GSGF_TYPE_EMPTY             (gsgf_empty_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_EMPTY</NAME>
#define GSGF_EMPTY(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
                GSGF_TYPE_EMPTY, GSGFEmpty))
</MACRO>
<MACRO>
<NAME>GSGF_EMPTY_CLASS</NAME>
#define GSGF_EMPTY_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), \
                GSGF_TYPE_EMPTY, GSGFEmptyClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_EMPTY</NAME>
#define GSGF_IS_EMPTY(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
                GSGF_TYPE_EMPTY))
</MACRO>
<MACRO>
<NAME>GSGF_IS_EMPTY_CLASS</NAME>
#define GSGF_IS_EMPTY_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
                GSGF_TYPE_EMPTY))
</MACRO>
<MACRO>
<NAME>GSGF_EMPTY_GET_CLASS</NAME>
#define GSGF_EMPTY_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), \
                GSGF_TYPE_EMPTY, GSGFEmptyClass))
</MACRO>
<STRUCT>
<NAME>GSGFEmpty</NAME>
struct _GSGFEmpty
{
        GSGFCookedValue parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GSGFEmptyClass</NAME>
struct _GSGFEmptyClass
{
        /*< private >*/
        GSGFCookedValueClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_empty_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gsgf_empty_new</NAME>
<RETURNS>GSGFEmpty  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gsgf_empty_new_from_raw</NAME>
<RETURNS>GSGFCookedValue  *</RETURNS>
const GSGFRaw* raw, const GSGFFlavor *flavor, const struct _GSGFProperty *property, GError **error
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_PROPERTY</NAME>
#define GSGF_TYPE_PROPERTY             (gsgf_property_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_PROPERTY</NAME>
#define GSGF_PROPERTY(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
		GSGF_TYPE_PROPERTY, GSGFProperty))
</MACRO>
<MACRO>
<NAME>GSGF_PROPERTY_CLASS</NAME>
#define GSGF_PROPERTY_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), \
		GSGF_TYPE_PROPERTY, GSGFPropertyClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_PROPERTY</NAME>
#define GSGF_IS_PROPERTY(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
		GSGF_TYPE_PROPERTY))
</MACRO>
<MACRO>
<NAME>GSGF_IS_PROPERTY_CLASS</NAME>
#define GSGF_IS_PROPERTY_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
		GSGF_TYPE_PROPERTY))
</MACRO>
<MACRO>
<NAME>GSGF_PROPERTY_GET_CLASS</NAME>
#define GSGF_PROPERTY_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), \
		GSGF_TYPE_PROPERTY, GSGFPropertyClass))
</MACRO>
<STRUCT>
<NAME>GSGFProperty</NAME>
struct _GSGFProperty
{
        GObject parent_instance;

        /*< private >*/
        struct _GSGFPropertyPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GSGFPropertyClass</NAME>
struct _GSGFPropertyClass
{
        /*< private >*/
        GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_property_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gsgf_property_get_id</NAME>
<RETURNS>const gchar  *</RETURNS>
const GSGFProperty *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_property_get_node</NAME>
<RETURNS>GSGFNode  *</RETURNS>
const GSGFProperty *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_property_get_value</NAME>
<RETURNS>GSGFValue  *</RETURNS>
const GSGFProperty* self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_property_set_value</NAME>
<RETURNS>gboolean  </RETURNS>
GSGFProperty *self, GSGFValue *value, GError **error
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_DOUBLE</NAME>
#define GSGF_TYPE_DOUBLE \
        (gsgf_double_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_DOUBLE</NAME>
#define GSGF_DOUBLE(obj) \
        (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_DOUBLE, \
                GSGFDouble))
</MACRO>
<MACRO>
<NAME>GSGF_DOUBLE_CLASS</NAME>
#define GSGF_DOUBLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), \
        GSGF_TYPE_DOUBLE, GSGFDoubleClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_DOUBLE</NAME>
#define GSGF_IS_DOUBLE(obj) \
        (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
                GSGF_TYPE_DOUBLE))
</MACRO>
<MACRO>
<NAME>GSGF_IS_DOUBLE_CLASS</NAME>
#define GSGF_IS_DOUBLE_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_TYPE ((klass), \
                GSGF_TYPE_DOUBLE))
</MACRO>
<MACRO>
<NAME>GSGF_DOUBLE_GET_CLASS</NAME>
#define GSGF_DOUBLE_GET_CLASS(obj) \
        (G_TYPE_INSTANCE_GET_CLASS (obj), \
                GSGF_TYPE_DOUBLE, GSGFDoubleClass))
</MACRO>
<STRUCT>
<NAME>GSGFDouble</NAME>
struct _GSGFDouble
{
        GSGFNumber parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GSGFDoubleClass</NAME>
struct _GSGFDoubleClass
{
        /* <private >*/
        GSGFNumberClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_double_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GSGFDoubleEnum</NAME>
typedef enum {
        GSGF_DOUBLE_NORMAL = 1,
        GSGF_DOUBLE_VERY = 2
} GSGFDoubleEnum;
</ENUM>
<FUNCTION>
<NAME>gsgf_double_new</NAME>
<RETURNS>GSGFDouble  *</RETURNS>
GSGFDoubleEnum grade
</FUNCTION>
<FUNCTION>
<NAME>gsgf_double_new_from_raw</NAME>
<RETURNS>GSGFCookedValue  *</RETURNS>
const GSGFRaw* raw, const GSGFFlavor *flavor, const struct _GSGFProperty *property, GError **error
</FUNCTION>
<FUNCTION>
<NAME>gsgf_double_set_value</NAME>
<RETURNS>void  </RETURNS>
GSGFDouble *self, GSGFDoubleEnum value
</FUNCTION>
<FUNCTION>
<NAME>gsgf_double_get_value</NAME>
<RETURNS>GSGFDoubleEnum  </RETURNS>
const GSGFDouble *self
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_FLAVOR</NAME>
#define GSGF_TYPE_FLAVOR             (gsgf_flavor_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_FLAVOR</NAME>
#define GSGF_FLAVOR(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
		GSGF_TYPE_FLAVOR, GSGFFlavor))
</MACRO>
<MACRO>
<NAME>GSGF_FLAVOR_CLASS</NAME>
#define GSGF_FLAVOR_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), \
		GSGF_TYPE_FLAVOR, GSGFFlavorClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_FLAVOR</NAME>
#define GSGF_IS_FLAVOR(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
		GSGF_TYPE_FLAVOR))
</MACRO>
<MACRO>
<NAME>GSGF_IS_FLAVOR_CLASS</NAME>
#define GSGF_IS_FLAVOR_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
		GSGF_TYPE_FLAVOR))
</MACRO>
<MACRO>
<NAME>GSGF_FLAVOR_GET_CLASS</NAME>
#define GSGF_FLAVOR_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), \
		GSGF_TYPE_FLAVOR, GSGFFlavorClass))
</MACRO>
<STRUCT>
<NAME>GSGFFlavor</NAME>
struct _GSGFFlavor
{
        GObject parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GSGFFlavorClass</NAME>
struct _GSGFFlavorClass
{
        /*< private >*/
        GObjectClass parent_class;

        gboolean (*get_cooked_value) (const GSGFFlavor *flavor,
                                      const struct _GSGFProperty *property,
                                      const struct _GSGFRaw *raw,
                                      struct _GSGFCookedValue **cooked,
                                      GError **error);

        struct _GSGFMove *(*create_move) (const GSGFFlavor *flavor,
                                          const struct _GSGFRaw *raw,
                                          GError **error);
        GType stone_type;
        struct _GSGFStone *(*create_stone) (const GSGFFlavor *flavor,
                                            const struct _GSGFRaw *raw,
                                            gsize i,
                                            GError **error);

        GType point_type;
        struct _GSGFPoint *(*create_point) (const GSGFFlavor *flavor,
                                            const struct _GSGFRaw *raw,
                                            gsize i,
                                            GError **error);
        gboolean (*append_points) (const GSGFFlavor *flavor,
                                   struct _GSGFListOf *list_of,
                                   const struct _GSGFRaw *raw,
                                   gsize i,
                                   GError **error);

        gboolean (*write_compressed_list) (const GSGFFlavor *flavor,
                                           const struct _GSGFListOf *list_of,
                                           GOutputStream *out,
                                           gsize *bytes_written,
                                           GCancellable *cancellable,
                                           GError **error);

        guint (*get_game_id) (const GSGFFlavor *flavor);
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_flavor_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gsgf_flavor_new</NAME>
<RETURNS>GSGFFlavor  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gsgf_flavor_get_cooked_value</NAME>
<RETURNS>gboolean  </RETURNS>
const GSGFFlavor *self, const struct _GSGFProperty *property, const struct _GSGFRaw *raw, struct _GSGFCookedValue **cooked, GError **error
</FUNCTION>
<FUNCTION>
<NAME>gsgf_flavor_get_game_id</NAME>
<RETURNS>guint  </RETURNS>
const GSGFFlavor *self, GError **error
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_FLAVOR_BACKGAMMON</NAME>
#define GSGF_TYPE_FLAVOR_BACKGAMMON  (gsgf_flavor_backgammon_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_FLAVOR_BACKGAMMON</NAME>
#define GSGF_FLAVOR_BACKGAMMON(obj)             \
	(G_TYPE_CHECK_INSTANCE_CAST ((obj), \
			GSGF_TYPE_FLAVOR_BACKGAMMON, GSGFFlavorBackgammon))
</MACRO>
<MACRO>
<NAME>GSGF_FLAVOR_BACKGAMMON_CLASS</NAME>
#define GSGF_FLAVOR_BACKGAMMON_CLASS(klass)     \
	(G_TYPE_CHECK_CLASS_CAST ((klass), \
			GSGF_TYPE_FLAVOR_BACKGAMMON, GSGFFlavorBackgammonClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_FLAVOR_BACKGAMMON</NAME>
#define GSGF_IS_FLAVOR_BACKGAMMON(obj)          \
	(G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_FLAVOR_BACKGAMMON))
</MACRO>
<MACRO>
<NAME>GSGF_IS_FLAVOR_BACKGAMMON_CLASS</NAME>
#define GSGF_IS_FLAVOR_BACKGAMMON_CLASS(klass)  \
	(G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_FLAVOR_BACKGAMMON))
</MACRO>
<MACRO>
<NAME>GSGF_FLAVOR_BACKGAMMON_GET_CLASS</NAME>
#define GSGF_FLAVOR_BACKGAMMON_GET_CLASS(obj)   \
	(G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_FLAVOR_BACKGAMMON, \
			GSGFFlavorBackgammonClass))
</MACRO>
<STRUCT>
<NAME>GSGFFlavorBackgammon</NAME>
struct _GSGFFlavorBackgammon
{
        GSGFFlavor parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GSGFFlavorBackgammonClass</NAME>
struct _GSGFFlavorBackgammonClass
{
        /*< private >*/
        GSGFFlavorClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_flavor_backgammon_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gsgf_flavor_backgammon_new</NAME>
<RETURNS>GSGFFlavor  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_SIMPLE_TEXT</NAME>
#define GSGF_TYPE_SIMPLE_TEXT             (gsgf_simple_text_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_SIMPLE_TEXT</NAME>
#define GSGF_SIMPLE_TEXT(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
                GSGF_TYPE_SIMPLE_TEXT, GSGFSimpleText))
</MACRO>
<MACRO>
<NAME>GSGF_SIMPLE_TEXT_CLASS</NAME>
#define GSGF_SIMPLE_TEXT_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), \
                GSGF_TYPE_SIMPLE_TEXT, GSGFSimpleTextClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_SIMPLE_TEXT</NAME>
#define GSGF_IS_SIMPLE_TEXT(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
                GSGF_TYPE_SIMPLE_TEXT))
</MACRO>
<MACRO>
<NAME>GSGF_IS_SIMPLE_TEXT_CLASS</NAME>
#define GSGF_IS_SIMPLE_TEXT_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
                GSGF_TYPE_SIMPLE_TEXT))
</MACRO>
<MACRO>
<NAME>GSGF_SIMPLE_TEXT_GET_CLASS</NAME>
#define GSGF_SIMPLE_TEXT_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), \
                GSGF_TYPE_SIMPLE_TEXT, GSGFSimpleTextClass))
</MACRO>
<STRUCT>
<NAME>GSGFSimpleText</NAME>
struct _GSGFSimpleText
{
        GSGFText parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GSGFSimpleTextClass</NAME>
struct _GSGFSimpleTextClass
{
        /*< private >*/
        GSGFTextClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_simple_text_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gsgf_simple_text_new</NAME>
<RETURNS>GSGFSimpleText * </RETURNS>
const gchar *value
</FUNCTION>
<FUNCTION>
<NAME>gsgf_simple_text_new_from_raw</NAME>
<RETURNS>GSGFCookedValue * </RETURNS>
const GSGFRaw *raw, const GSGFFlavor *flavor, const struct _GSGFProperty *property, GError **error
</FUNCTION>
<ENUM>
<NAME>GSGFError</NAME>
typedef enum {
        GSGF_ERROR_NONE = 0,
        GSGF_ERROR_FLAVOR_UNSUPPORTED = 1,
        GSGF_ERROR_FLAVOR_MISMATCH = 2,
        GSGF_ERROR_SYNTAX = 3,
        GSGF_ERROR_EMPTY_COLLECTION = 4,
        GSGF_ERROR_PROPERTY_EXISTS = 5,
        GSGF_ERROR_EMPTY_PROPERTY = 6,
        GSGF_ERROR_INTERNAL_ERROR = 7,
        GSGF_ERROR_INVALID_NUMBER = 8,
        GSGF_ERROR_NAN = 9,
        GSGF_ERROR_LIST_TOO_LONG = 10,
        GSGF_ERROR_LIST_EMPTY = 11,
        GSGF_ERROR_SEMANTIC_ERROR = 12,
        GSGF_ERROR_INVALID_MOVE = 14,
        GSGF_ERROR_INVALID_POINT = 15,
        GSGF_ERROR_INVALID_STONE = 16,
        GSGF_ERROR_USAGE_ERROR = 17,
        GSGF_ERROR_NON_UNIQUE_POINT = 18,
        GSGF_ERROR_NON_UNIQUE_STONE = 19,
        GSGF_ERROR_DOUBLE_OUT_OF_RANGE = 20,
        GSGF_ERROR_INVALID_DATE_FORMAT = 21
} GSGFError;
</ENUM>
<MACRO>
<NAME>GSGF_ERROR</NAME>
#define GSGF_ERROR gsgf_error_quark ()
</MACRO>
<FUNCTION>
<NAME>gsgf_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_VALUE</NAME>
#define GSGF_TYPE_VALUE \
        (gsgf_value_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_VALUE</NAME>
#define GSGF_VALUE(obj) \
        (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_VALUE, \
                GSGFValue))
</MACRO>
<MACRO>
<NAME>GSGF_VALUE_CLASS</NAME>
#define GSGF_VALUE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), \
        GSGF_TYPE_VALUE, GSGFValueClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_VALUE</NAME>
#define GSGF_IS_VALUE(obj) \
        (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
                GSGF_TYPE_VALUE))
</MACRO>
<MACRO>
<NAME>GSGF_IS_VALUE_CLASS</NAME>
#define GSGF_IS_VALUE_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_TYPE ((klass), \
                GSGF_TYPE_VALUE))
</MACRO>
<MACRO>
<NAME>GSGF_VALUE_GET_CLASS</NAME>
#define GSGF_VALUE_GET_CLASS(obj) \
        (G_TYPE_INSTANCE_GET_CLASS ((obj), \
                GSGF_TYPE_VALUE, GSGFValueClass))
</MACRO>
<STRUCT>
<NAME>GSGFValue</NAME>
struct _GSGFValue
{
        GObject parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GSGFValueClass</NAME>
struct _GSGFValueClass
{
        /* <private >*/
        GObjectClass parent_class;

        gboolean (*write_stream) (const GSGFValue *self,
                                  GOutputStream *out, gsize *bytes_written,
                                  GCancellable *cancellable, GError **error);
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_value_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gsgf_value_write_stream</NAME>
<RETURNS>gboolean  </RETURNS>
const GSGFValue *self, GOutputStream *out, gsize *bytes_written, GCancellable *cancellable, GError **error
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_NUMBER</NAME>
#define GSGF_TYPE_NUMBER             (gsgf_number_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_NUMBER</NAME>
#define GSGF_NUMBER(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
		GSGF_TYPE_NUMBER, GSGFNumber))
</MACRO>
<MACRO>
<NAME>GSGF_NUMBER_CLASS</NAME>
#define GSGF_NUMBER_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), \
		GSGF_TYPE_NUMBER, GSGFNumberClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_NUMBER</NAME>
#define GSGF_IS_NUMBER(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
		GSGF_TYPE_NUMBER))
</MACRO>
<MACRO>
<NAME>GSGF_IS_NUMBER_CLASS</NAME>
#define GSGF_IS_NUMBER_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
		GSGF_TYPE_NUMBER))
</MACRO>
<MACRO>
<NAME>GSGF_NUMBER_GET_CLASS</NAME>
#define GSGF_NUMBER_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), \
		GSGF_TYPE_NUMBER, GSGFNumberClass))
</MACRO>
<STRUCT>
<NAME>GSGFNumber</NAME>
struct _GSGFNumber
{
        GSGFCookedValue parent_instance;

        /*< private >*/
        struct _GSGFNumberPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GSGFNumberClass</NAME>
struct _GSGFNumberClass
{
        /*< private >*/
        GSGFCookedValueClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_number_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gsgf_number_new</NAME>
<RETURNS>GSGFNumber  *</RETURNS>
gint64 value
</FUNCTION>
<FUNCTION>
<NAME>gsgf_number_new_from_raw</NAME>
<RETURNS>GSGFCookedValue  *</RETURNS>
const GSGFRaw* raw, const GSGFFlavor *flavor, const struct _GSGFProperty *property, GError **error
</FUNCTION>
<FUNCTION>
<NAME>gsgf_number_set_value</NAME>
<RETURNS>void  </RETURNS>
GSGFNumber *self, gint64 value
</FUNCTION>
<FUNCTION>
<NAME>gsgf_number_get_value</NAME>
<RETURNS>gint64  </RETURNS>
const GSGFNumber *self
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_COMPONENT</NAME>
#define GSGF_TYPE_COMPONENT \
        (gsgf_component_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_COMPONENT</NAME>
#define GSGF_COMPONENT(obj) \
        (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_COMPONENT, \
                GSGFComponent))
</MACRO>
<MACRO>
<NAME>GSGF_IS_COMPONENT</NAME>
#define GSGF_IS_COMPONENT(obj) \
        (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
                GSGF_TYPE_COMPONENT))
</MACRO>
<MACRO>
<NAME>GSGF_COMPONENT_GET_IFACE</NAME>
#define GSGF_COMPONENT_GET_IFACE(obj) \
        (G_TYPE_INSTANCE_GET_INTERFACE ((obj), \
                GSGF_TYPE_COMPONENT, GSGFComponentIface))
</MACRO>
<STRUCT>
<NAME>GSGFComponent</NAME>
struct _GSGFComponent {
        /* Make gtk-doc happy! */
};
</STRUCT>
<STRUCT>
<NAME>GSGFComponentIface</NAME>
struct _GSGFComponentIface
{
        GTypeInterface g_iface;

        /* Virtual table.  */
        gboolean (*cook) (GSGFComponent *self,
                          GSGFComponent **culprit,
                          GError **error);

        gboolean (*write_stream) (const GSGFComponent *self,
                                  GOutputStream *out,
                                  gsize *bytes_written,
                                  GCancellable *cancellable,
                                  GError **error);

        /*< private >*/
        gboolean (*_convert) (GSGFComponent *self, const gchar *charset,
                              GError **error);
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_component_write_stream</NAME>
<RETURNS>gboolean  </RETURNS>
const GSGFComponent *self, GOutputStream *out, gsize *bytes_written, GCancellable *cancellable, GError **error
</FUNCTION>
<FUNCTION>
<NAME>gsgf_component_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gsgf_component_cook</NAME>
<RETURNS>gboolean  </RETURNS>
GSGFComponent *self, GSGFComponent **culprit, GError **error
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_RAW</NAME>
#define GSGF_TYPE_RAW             (gsgf_raw_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_RAW</NAME>
#define GSGF_RAW(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
		GSGF_TYPE_RAW, GSGFRaw))
</MACRO>
<MACRO>
<NAME>GSGF_RAW_CLASS</NAME>
#define GSGF_RAW_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), \
		GSGF_TYPE_RAW, GSGFRawClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_RAW</NAME>
#define GSGF_IS_RAW(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
		GSGF_TYPE_RAW))
</MACRO>
<MACRO>
<NAME>GSGF_IS_RAW_CLASS</NAME>
#define GSGF_IS_RAW_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
		GSGF_TYPE_RAW))
</MACRO>
<MACRO>
<NAME>GSGF_RAW_GET_CLASS</NAME>
#define GSGF_RAW_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), \
		GSGF_TYPE_RAW, GSGFRawClass))
</MACRO>
<STRUCT>
<NAME>GSGFRaw</NAME>
struct _GSGFRaw
{
        GSGFValue parent_instance;

        /*< private >*/
        struct _GSGFRawPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GSGFRawClass</NAME>
struct _GSGFRawClass
{
        /*< private >*/
        GSGFCookedValueClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_raw_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gsgf_raw_new</NAME>
<RETURNS>GSGFRaw * </RETURNS>
const gchar *value
</FUNCTION>
<FUNCTION>
<NAME>gsgf_raw_get_number_of_values</NAME>
<RETURNS>gsize  </RETURNS>
const GSGFRaw *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_raw_get_value</NAME>
<RETURNS>gchar  *</RETURNS>
const GSGFRaw *self, gsize i
</FUNCTION>
<FUNCTION>
<NAME>gsgf_raw_add_value</NAME>
<RETURNS>void  </RETURNS>
GSGFRaw *self, const gchar *value
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_COMPOSE</NAME>
#define GSGF_TYPE_COMPOSE             (gsgf_compose_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_COMPOSE</NAME>
#define GSGF_COMPOSE(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
                GSGF_TYPE_COMPOSE, GSGFCompose))
</MACRO>
<MACRO>
<NAME>GSGF_COMPOSE_CLASS</NAME>
#define GSGF_COMPOSE_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), \
                GSGF_TYPE_COMPOSE, GSGFComposeClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_COMPOSE</NAME>
#define GSGF_IS_COMPOSE(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
                GSGF_TYPE_COMPOSE))
</MACRO>
<MACRO>
<NAME>GSGF_IS_COMPOSE_CLASS</NAME>
#define GSGF_IS_COMPOSE_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
                GSGF_TYPE_COMPOSE))
</MACRO>
<MACRO>
<NAME>GSGF_COMPOSE_GET_CLASS</NAME>
#define GSGF_COMPOSE_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), \
                GSGF_TYPE_COMPOSE, GSGFComposeClass))
</MACRO>
<STRUCT>
<NAME>GSGFCompose</NAME>
struct _GSGFCompose
{
        GSGFCookedValue parent_instance;

        /*< private >*/
        struct _GSGFComposePrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GSGFComposeClass</NAME>
struct _GSGFComposeClass
{
        /*< private >*/
        GSGFCookedValueClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_compose_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gsgf_compose_new</NAME>
<RETURNS>GSGFCompose  *</RETURNS>
GSGFCookedValue *value, ...
</FUNCTION>
<FUNCTION>
<NAME>gsgf_compose_get_number_of_values</NAME>
<RETURNS>gsize  </RETURNS>
const GSGFCompose *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_compose_get_value</NAME>
<RETURNS>GSGFCookedValue  *</RETURNS>
const GSGFCompose *self, gsize i
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_STONE</NAME>
#define GSGF_TYPE_STONE             (gsgf_stone_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_STONE</NAME>
#define GSGF_STONE(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
                GSGF_TYPE_STONE, GSGFStone))
</MACRO>
<MACRO>
<NAME>GSGF_STONE_CLASS</NAME>
#define GSGF_STONE_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), \
                GSGF_TYPE_STONE, GSGFStoneClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_STONE</NAME>
#define GSGF_IS_STONE(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
                GSGF_TYPE_STONE))
</MACRO>
<MACRO>
<NAME>GSGF_IS_STONE_CLASS</NAME>
#define GSGF_IS_STONE_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
                GSGF_TYPE_STONE))
</MACRO>
<MACRO>
<NAME>GSGF_STONE_GET_CLASS</NAME>
#define GSGF_STONE_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), \
                GSGF_TYPE_STONE, GSGFStoneClass))
</MACRO>
<STRUCT>
<NAME>GSGFStone</NAME>
struct _GSGFStone
{
        GSGFCookedValue parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GSGFStoneClass</NAME>
struct _GSGFStoneClass
{
        /*< private >*/
        GSGFCookedValueClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_stone_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_REAL</NAME>
#define GSGF_TYPE_REAL             (gsgf_real_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_REAL</NAME>
#define GSGF_REAL(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
		GSGF_TYPE_REAL, GSGFReal))
</MACRO>
<MACRO>
<NAME>GSGF_REAL_CLASS</NAME>
#define GSGF_REAL_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), \
		GSGF_TYPE_REAL, GSGFRealClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_REAL</NAME>
#define GSGF_IS_REAL(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
		GSGF_TYPE_REAL))
</MACRO>
<MACRO>
<NAME>GSGF_IS_REAL_CLASS</NAME>
#define GSGF_IS_REAL_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
		GSGF_TYPE_REAL))
</MACRO>
<MACRO>
<NAME>GSGF_REAL_GET_CLASS</NAME>
#define GSGF_REAL_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), \
		GSGF_TYPE_REAL, GSGFRealClass))
</MACRO>
<STRUCT>
<NAME>GSGFReal</NAME>
struct _GSGFReal
{
        GSGFCookedValue parent_instance;

        /*< private >*/
        struct _GSGFRealPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GSGFRealClass</NAME>
struct _GSGFRealClass
{
        /*< private >*/
        GSGFCookedValueClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_real_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gsgf_real_new</NAME>
<RETURNS>GSGFReal * </RETURNS>
gdouble value
</FUNCTION>
<FUNCTION>
<NAME>gsgf_real_new_from_raw</NAME>
<RETURNS>GSGFCookedValue  *</RETURNS>
const GSGFRaw* raw, const GSGFFlavor *flavor, const struct _GSGFProperty *property, GError **error
</FUNCTION>
<FUNCTION>
<NAME>gsgf_real_set_value</NAME>
<RETURNS>void  </RETURNS>
GSGFReal *self, gdouble value
</FUNCTION>
<FUNCTION>
<NAME>gsgf_real_get_value</NAME>
<RETURNS>gdouble  </RETURNS>
const GSGFReal *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_real_to_string</NAME>
<RETURNS>gchar  *</RETURNS>
const GSGFReal *self
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_POINT</NAME>
#define GSGF_TYPE_POINT             (gsgf_point_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_POINT</NAME>
#define GSGF_POINT(obj)             \
	(G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_POINT, GSGFPoint))
</MACRO>
<MACRO>
<NAME>GSGF_POINT_CLASS</NAME>
#define GSGF_POINT_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), \
		GSGF_TYPE_POINT, GSGFPointClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_POINT</NAME>
#define GSGF_IS_POINT(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
		GSGF_TYPE_POINT))
</MACRO>
<MACRO>
<NAME>GSGF_IS_POINT_CLASS</NAME>
#define GSGF_IS_POINT_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
		GSGF_TYPE_POINT))
</MACRO>
<MACRO>
<NAME>GSGF_POINT_GET_CLASS</NAME>
#define GSGF_POINT_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), \
		GSGF_TYPE_POINT, GSGFPointClass))
</MACRO>
<STRUCT>
<NAME>GSGFPoint</NAME>
struct _GSGFPoint
{
        /*< private >*/
        GSGFCookedValue parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GSGFPointClass</NAME>
struct _GSGFPointClass
{
        /*< private >*/
        GSGFCookedValueClass parent_class;

        gint (*get_normalized_value) (const struct _GSGFPoint *self);
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_point_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gsgf_point_get_normalized_value</NAME>
<RETURNS>gint  </RETURNS>
const GSGFPoint *self
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_MOVE</NAME>
#define GSGF_TYPE_MOVE             (gsgf_move_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_MOVE</NAME>
#define GSGF_MOVE(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
		GSGF_TYPE_MOVE, GSGFMove))
</MACRO>
<MACRO>
<NAME>GSGF_MOVE_CLASS</NAME>
#define GSGF_MOVE_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), \
		GSGF_TYPE_MOVE, GSGFMoveClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_MOVE</NAME>
#define GSGF_IS_MOVE(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
		GSGF_TYPE_MOVE))
</MACRO>
<MACRO>
<NAME>GSGF_IS_MOVE_CLASS</NAME>
#define GSGF_IS_MOVE_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
		GSGF_TYPE_MOVE))
</MACRO>
<MACRO>
<NAME>GSGF_MOVE_GET_CLASS</NAME>
#define GSGF_MOVE_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), \
		GSGF_TYPE_MOVE, GSGFMoveClass))
</MACRO>
<STRUCT>
<NAME>GSGFMove</NAME>
struct _GSGFMove
{
        /*< private >*/
        GSGFCookedValue parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GSGFMoveClass</NAME>
struct _GSGFMoveClass
{
        /*< private >*/
        GSGFCookedValueClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_move_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_STONE_BACKGAMMON</NAME>
#define GSGF_TYPE_STONE_BACKGAMMON  (gsgf_stone_backgammon_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_STONE_BACKGAMMON</NAME>
#define GSGF_STONE_BACKGAMMON(obj)             \
	(G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_STONE_BACKGAMMON, \
	                GSGFStoneBackgammon))
</MACRO>
<MACRO>
<NAME>GSGF_STONE_BACKGAMMON_CLASS</NAME>
#define GSGF_STONE_BACKGAMMON_CLASS(klass)     \
	(G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_STONE_BACKGAMMON, \
	                GSGFStoneBackgammonClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_STONE_BACKGAMMON</NAME>
#define GSGF_IS_STONE_BACKGAMMON(obj)         \
	(G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_STONE_BACKGAMMON))
</MACRO>
<MACRO>
<NAME>GSGF_IS_STONE_BACKGAMMON_CLASS</NAME>
#define GSGF_IS_STONE_BACKGAMMON_CLASS(klass)  \
	(G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_STONE_BACKGAMMON))
</MACRO>
<MACRO>
<NAME>GSGF_STONE_BACKGAMMON_GET_CLASS</NAME>
#define GSGF_STONE_BACKGAMMON_GET_CLASS(obj)   \
	(G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_STONE_BACKGAMMON, \
			GSGFStoneBackgammonClass))
</MACRO>
<STRUCT>
<NAME>GSGFStoneBackgammon</NAME>
struct _GSGFStoneBackgammon
{
        GSGFStone parent_instance;

        /*< private >*/
        struct _GSGFStoneBackgammonPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GSGFStoneBackgammonClass</NAME>
struct _GSGFStoneBackgammonClass
{
        /*< private >*/
        GSGFStoneClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_stone_backgammon_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gsgf_stone_backgammon_new</NAME>
<RETURNS>GSGFStoneBackgammon  *</RETURNS>
gint stone
</FUNCTION>
<FUNCTION>
<NAME>gsgf_stone_backgammon_new_from_raw</NAME>
<RETURNS>GSGFStoneBackgammon  *</RETURNS>
const GSGFRaw *raw, gsize i, GError **error
</FUNCTION>
<FUNCTION>
<NAME>gsgf_stone_backgammon_get_stone</NAME>
<RETURNS>gint  </RETURNS>
const GSGFStoneBackgammon *self
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_LIST_OF</NAME>
#define GSGF_TYPE_LIST_OF             (gsgf_list_of_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_LIST_OF</NAME>
#define GSGF_LIST_OF(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), \
		GSGF_TYPE_LIST_OF, GSGFListOf))
</MACRO>
<MACRO>
<NAME>GSGF_LIST_OF_CLASS</NAME>
#define GSGF_LIST_OF_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), \
		GSGF_TYPE_LIST_OF, GSGFListOfClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_LIST_OF</NAME>
#define GSGF_IS_LIST_OF(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), \
		GSGF_TYPE_LIST_OF))
</MACRO>
<MACRO>
<NAME>GSGF_IS_LIST_OF_CLASS</NAME>
#define GSGF_IS_LIST_OF_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), \
		GSGF_TYPE_LIST_OF))
</MACRO>
<MACRO>
<NAME>GSGF_LIST_OF_GET_CLASS</NAME>
#define GSGF_LIST_OF_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), \
		GSGF_TYPE_LIST_OF, GSGFListOfClass))
</MACRO>
<STRUCT>
<NAME>GSGFListOf</NAME>
struct _GSGFListOf
{
        GSGFCookedValue parent_instance;

        /*< private >*/
        struct _GSGFListOfPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GSGFListOfClass</NAME>
struct _GSGFListOfClass
{
        /*< private >*/
        GSGFCookedValueClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_list_of_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gsgf_list_of_new</NAME>
<RETURNS>GSGFListOf  *</RETURNS>
GType type, const GSGFFlavor *flavor
</FUNCTION>
<FUNCTION>
<NAME>gsgf_list_of_get_item_type</NAME>
<RETURNS>GType  </RETURNS>
const GSGFListOf *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_list_of_get_number_of_items</NAME>
<RETURNS>gsize  </RETURNS>
const GSGFListOf *self
</FUNCTION>
<FUNCTION>
<NAME>gsgf_list_of_append</NAME>
<RETURNS>gboolean  </RETURNS>
GSGFListOf *self, GSGFCookedValue *item, GError **error
</FUNCTION>
<FUNCTION>
<NAME>gsgf_list_of_get_nth_item</NAME>
<RETURNS>GSGFCookedValue  *</RETURNS>
const GSGFListOf *self, gsize i
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_TEXT</NAME>
#define GSGF_TYPE_TEXT             (gsgf_text_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_TEXT</NAME>
#define GSGF_TEXT(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_TEXT, GSGFText))
</MACRO>
<MACRO>
<NAME>GSGF_TEXT_CLASS</NAME>
#define GSGF_TEXT_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_TEXT, GSGFTextClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_TEXT</NAME>
#define GSGF_IS_TEXT(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_TEXT))
</MACRO>
<MACRO>
<NAME>GSGF_IS_TEXT_CLASS</NAME>
#define GSGF_IS_TEXT_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_TEXT))
</MACRO>
<MACRO>
<NAME>GSGF_TEXT_GET_CLASS</NAME>
#define GSGF_TEXT_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_TEXT, GSGFTextClass))
</MACRO>
<STRUCT>
<NAME>GSGFText</NAME>
struct _GSGFText
{
        GSGFCookedValue parent_instance;

        /*< private >*/
        struct _GSGFTextPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GSGFTextClass</NAME>
struct _GSGFTextClass
{
        /*< private >*/
        GSGFCookedValueClass parent_class;

        gboolean (*set_value) (GSGFText *self, const gchar *value,
                               gboolean copy, GError **error);
        gchar * (*get_value) (const GSGFText *self);
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_text_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gsgf_text_new</NAME>
<RETURNS>GSGFText * </RETURNS>
const gchar *value
</FUNCTION>
<FUNCTION>
<NAME>gsgf_text_new_from_raw</NAME>
<RETURNS>GSGFCookedValue * </RETURNS>
const GSGFRaw *raw, const GSGFFlavor *flavor, const struct _GSGFProperty *property, GError **error
</FUNCTION>
<FUNCTION>
<NAME>gsgf_text_set_value</NAME>
<RETURNS>gboolean  </RETURNS>
GSGFText *self, const gchar *value, gboolean copy, GError **error
</FUNCTION>
<FUNCTION>
<NAME>gsgf_text_get_value</NAME>
<RETURNS>gchar  *</RETURNS>
const GSGFText *self
</FUNCTION>
